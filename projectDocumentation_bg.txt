ПРОЕКТ № 8 КАРТА НА ГРАД

УСЛОВИЕ
Да се реализира програма, която представя карта на град. Информацията за картата се съдържа в текстов файл. На всеки ред във файла на първа позиция стои името на дадено  кръстовище, а след него двойки от имена на други кръстовища и дължината на улицата от първото кръстовище до второто, например:
Попа БСФС 150 5Кьошета 1000
БСФС Попа 150
5Кьошета НДК 400
НДК Попа 800

Забележете, че е възможно да има еднопосочни улици, също така е възможно улиците в двете различни посоки да са различни по дължина, но не е възможно да има две различни улици в една и съща посока между едни и същи кръстовища.
За тази карта да се реализират:
1. Проверка дали има път между две зададени кръстовища.
2. Намиране на трите най-кратки пътя между две зададени кръстовища.
3. При наличието на затворени кръстовища (които да бъдат подавани като списък) да
се намери трите алтернативни най-кратки пътища между две зададени
кръстовища.
4. Проверка дали при дадено кръстовище за начална точка е възможно да обиколим
част от града и върнем обратно там, откъдето сме тръгнали.
5. Проверка дали можем да направим пълна туристическа обиколка на всички улици
без да минаваме по една и съща улица два пъти. Ако такава обиколка е възможна,
да се намери маршрута на тази обиколка.
6. Проверка дали е възможно да стигнем от дадено кръстовище до всички останали.
7. Намиране на всички задънени улици (еднопосочна улица която свършва в
кръстовище от което не излизат улици). 
Улиците описваме като двойка от имената на кръстовището от което започва и кръстовището, където свършва.

Бонус:
Да се реализира интерактивен режим на изпълнение на програмата. Тя се стартира в този режим като при изпълнение на програмата се даде първи параметър  -i , последван от файла с картата и кръстовище на което се намираме. 
Чрез конкретния режим се дава достъп до следните команди:
1.	location — да се извежда кръстовището на което се намираме в момента
2.	change @ — да променя кръстовището на което се намираме
1.	neighbours — да извежда всички съседни кръстовища на настоящото (съседно кръстовище е такова, което можем да достигнем от настоящото, без да преминаваме пред междинни кръстовища)
2.	move @ — да премества текущата позиция от кръстовището, на което се намираме, до кръстовището, посочено на мястото на  @ , и извежда последователността от кръстовища през които се преминава, за да се достигне до там. Ако път от нашето кръстовище до подаденото няма, информация за това да се изведе на екрана и настоящото кръстовище да не бъде променяно
3.	close @— да се добави кръстовището, посочено в  @ , към списъка на затворените кръстовища
4.	open @— премахва кръстовището от списъка  @от списъка на затворените кръстовища
3.	closed — извежда всички затворени кръстовища
4.	tour — извежда маршрут на туристическа обиколка на града
ИЗПОЛЗВАНИ СТРУКТУРИ ДАННИ

Основната структура данни, с която работи приложението, е mCrossways:
map<string, Crossway> mCrossways

Предимствата от използването на map са:
1.	уникален ключ (името на всяко кръстовище), чрез който се осъществява достъп до всички свързани с него кръстовища. 
2.	не се налага да се грижим за повторения във входа от вида:
Попа 5кьошета 12
Попа НДК 30

Входните данни се четат от текстов файл, съдържанието на който е според условието. На всеки ред във файла на първа позиция стои името на дадено  кръстовище, а след него двойки от имена на други кръстовища и дължината на улицата от първото кръстовище до второто.

Прочетените данни се съхраняват в отделните елементи на цялата структура, визуализирана чрез следната ClassDiagram:
 


Отделните кръстовища се съхраняват структурата linkedCrossways, която е член-данна на клас Crossway. 

 	Class Base 
е базов клас, който се използва при вход/изхода на данни. 
В този клас е дефиниран виртуален метод processInput, имплементиран в клас System, производен на класа Base. Този метод обработва въведените от потребителя команди и извиква съответните методи (според избраните команди)

В клас Base са имплементирани методите start(), извикван в main()-a. В метода start се чете ред по ред, и помощния метод splitLine, който премаха излишни интервали и ни позволява по-лесно да четем данните от файл.

 	Class Crossway
Kлас, предназначен за съхраняване на данните за кръстовище string name;	
map<string, int> linkedCrossways; и операциите, свързани с тях.

 	Struct Edge
структура, която съдържа данните за ребро, съответно имената на начален и краен връх на реброто (string), нормер на ребро (int) и номер на краен връх на ребро 

 	Class System – наследник на клас Base
в него се имплементира цялата функционалност на проекта. 

Основната структура данно, с която представяме картата на град, е mCrossways.
map<string, Crossway> mCrossways. 

Както се вижда, ключ е името на кръстовище, а Crossway съдържа данните за самото кръстовище.

Методи на клас System, работещи с входните данни:

= void processInput() - обработва въведените от входа команди; 
= void openFromFile() – метод, който се извиква при избор на командата open от потребителя, с която се подава и името на файла, който трябва да се прочете. В тялото на този метод се извиеква методът fromStream(), който осъществява  четенето на данните от текстовия файл и ги зарежда в структурата данни mCrossways. 
= void printAllCrossways()– визуализира на екрана на монитора данните за всички кръстовища от картата на града.

Методи в клас System, реализиращи изискванинте по условие функционалности:
bool BFS(const vector<string> &vsplitLine); - 
void toDFS(const vector<string>& vsplitLine);
bool DFS(string numCrossways, map<string, bool> &visited, string par);
void dfs(map<string, vector<Edge>>& vE, string beg, stack<string> & tmp, vector<bool>& used);
bool isTour(const vector<string>& vsplitLine);
void Euler(map<string, vector<Edge>>& vE, string beg)
void blindAlleys(const vector<string>& vsplitLine);
bool Six(const vector<string> &vsplitLine);


Реализация на задача 1: 
Проверка дали има път между две зададени кръстовища.

Реализира се чрез извиква директно от потребителя чрез командата 

hasWay <crossName1> <crossName2>

Командата извиква метода 

bool BFS(const vector<string> &vsplitLine);

В променливите start и end кръстовищата между които ще проверяваме дали има път. Използвам един map<string, bool> visited, чрез който проверяваме кои кръстовища са посетени. 
В началото вкарваме в този map всички кръстовища от mCrossways (с тяхното име) и ги маркираме като непосетени.
За обхождането в ширина BFS, използваме помощна опашка queue<string>, като маркираме началното кръстовище за посетено и го слагаме в опашката.
Въртим цикъл, докато не се изпразни тази опашка.
Всеки път взимаме първия елемент от опашката, pop()-ваме го обхождаме неговите съседи и всички, които все още са непосетени, ги вкарваме в опашката, като ги маркираме за посетени. Ако при този процес достигнем до желания краен връх end излизаме от метода и връщаме true.
Ако излезем от цикъла, защото опашката се е изпразнила, а не защото сме достигнали крайния връх end, печатаме “No path” и връщаме false.

Реализация на задача 4: 
Проверка, дали при дадено кръстовище за начална точка е възможно да обиколим част от града и върнем обратно там, откъдето сме тръгнали.

Методи, използвани за решението:

void toDFS(const vector<string>& vsplitLine);
bool DFS(string numCrossways, map<string, bool> &visited, string par);

Тук реално търсим цикъл. За целта използваме DFS. Тъй като използваме рекурсивен алгоритъм, дефинираме отделен рекурсивен метод DFS.

Когато потребителят въведе командата:
iscycled <crosName>
 
се извиква методът toDFS(), а той извиква рекурсивн ия метод DFS()
Tова е същинският DFS, с аргументи string cur, map<string, bool> &visited, string par:

Действие: Маркираме началното за посетено и въртим един цикъл по свързаните с началното кръстовище кръстовища и ако има непосетено такова извикваме DFS за това текущо кръстовище и ако стигнем кръстовище par, връщаме true.

Итерираме по нашата основна структурна единица mCrossways, ако стигнем до кръстовище, различно от подаденото от потребителя, продължаваме да итерираме в цикъла. Ако има път от it.first до it.first , т.е. DFS(it.first, visited, it.first) (като it.first може да бъде само подаденото от потребителя) да връща true Значи сме получили цикъл и излизаме от метода.

Проверка дали е възможно да стигнем от дадено кръстовище до всички останали.
Идеята тук е да ползваме наготово вече използваният горе BFS, с малката разлика че няма никакво значение докъде ще стигнем. Просто всичко, което е възможно да се достигне се добавя в map-a visited и накрая имаме една проверка – ако има кръстовище, което не е било посетено значи няма път от стартовото до всички останали – връщаме false, в противен случай – true.
Намиране на всички задънени улици (еднопосочна улица която свършва в кръстовище от което не излизат улици). Улиците описваме като двойка от имената на кръстовището от което започва и кръстовището, където свършва.
Тук имаме една проста проверка. Итерираме всички кръстовища с итератора it, и за всяко it итерираме с t всички свързани с it кръстовища. Проверяваме ако имаме връзката it -> t такава че size() на свързаните с t кръстовища = 0 и от тук ще следва, че пътят it->t е задънен и ще го изведем на екрана.


Реализация на задача 5: Проверка дали при дадено кръстовище за начална точка е възможно да обиколим част от града и върнем обратно там, откъдето сме тръгнали.

Методи, използвани за решението:

bool isTour(const vector<string>& vsplitLine);
void Euler(map<string, vector<Edge>>& vE, string beg)
void dfs(map<string, vector<Edge>>& vE, string beg, stack<string> & tmp, vector<bool>& used)


Когато потребителят въведе командата:
istour
 
се извиква методът isTour(), койо проверява, дали графът е Ойлетров. Ако има ойлеров път или ойлеров цъкъл, се извиква методът Euler(), който извежда Ойлеровия път (цикъл). Иначе, ако графът не е ойлеров, извежда съобшение “No Euler Cycle!!”

Извеждането на Ойлеровия пътт (цикъл) се реализира чрез алгоритъма на Хиерхолцер – чрез dfs, извиквайки метода:
.

Реализация на задача 6:

void reachAllSrosways(const vector<string>& vsplitLine);
Реализация на задача 7:

   void blindAlleys(const vector<string>& vsplitLine);



